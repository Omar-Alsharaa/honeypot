import asyncio
import json
from datetime import datetime
from pathlib import Path
import argparse
import aiofiles
import urllib.parse

DEFAULT_SSH_BANNER = b"SSH-2.0-OpenSSH_4.3p2 Debian-3ubuntu5"

# A simulated "flag" for lab exercises. This is safe because it is never
# generated by executing attacker input; it's returned only when the exact
# expected pattern is seen in a request during an enabled lab session.
SIMULATED_FLAG = "FLAG{lab-simulated-12345}"

# default challenge definitions
CHALLENGES = {
    'easy':    {'mult': 0.5, 'desc': 'Easy challenge'},
    'normal':  {'mult': 1.0, 'desc': 'Normal challenge'},
    'hard':    {'mult': 2.0, 'desc': 'Hard challenge'},
    'expert':  {'mult': 4.0, 'desc': 'Expert challenge'},
    'hacker':  {'mult': 8.0, 'desc': 'Hacker challenge'}
}


class JSONLogger:
    def __init__(self, path: Path):
        self.path = path
        self.path.parent.mkdir(parents=True, exist_ok=True)

    async def log(self, entry: dict):
        entry.setdefault("ts", datetime.utcnow().isoformat() + "Z")
        async with aiofiles.open(self.path, "a", encoding="utf-8") as f:
            await f.write(json.dumps(entry, ensure_ascii=False) + "\n")


async def handle_ssh(reader: asyncio.StreamReader, writer: asyncio.StreamWriter, logger: JSONLogger):
    peer = writer.get_extra_info('peername')
    ip = peer[0] if peer else 'unknown'
    # send fake SSH banner
    writer.write(DEFAULT_SSH_BANNER + b"\r\n")
    await writer.drain()
    try:
        data = await asyncio.wait_for(reader.read(1024), timeout=5.0)
    except asyncio.TimeoutError:
        data = b""
    await logger.log({
        "proto": "ssh",
        "ip": ip,
        "banner_sent": DEFAULT_SSH_BANNER.decode('utf-8', errors='replace'),
        "payload": data.decode('utf-8', errors='replace')
    })
    try:
        writer.close()
        await writer.wait_closed()
    except Exception as e:
        import logging
        logging.warning(f"Error closing SSH writer: {e}")


def _simulate_vulnerability(payload: str, challenge: str = None):
    """Safely simulate outcomes for a 'vulnerable' endpoint.

    This function MUST NOT execute payloads. It performs string matching
    and returns a deterministic outcome useful for training and scoring.
    """
    outcome = {"exposed_flag": False, "message": "no effect", "points": 0, "vuln": None}
    p = (payload or "").lower()
    # scoring base points per vuln type
    base = {
        'flag': 50,
        'sqlinjection': 30,
        'lfi': 20,
        'rce': 100
    }
    # detect flag trigger
    if any(k in p for k in ("show_flag", "flag{", "give_me_flag")):
        outcome.update({"exposed_flag": True, "message": "flag revealed", "flag": SIMULATED_FLAG, "points": base['flag'], "vuln": 'flag'})
        # apply difficulty multiplier
        if challenge and challenge in CHALLENGES:
            outcome['points'] = int(outcome['points'] * CHALLENGES[challenge]['mult'])
        return outcome
    # SQLi patterns
    if 'union select' in p or ' or 1=1' in p or 'sqlmap' in p:
        outcome.update({"message": "simulated SQL injection detected", "points": base['sqlinjection'], "vuln": 'sqlinjection'})
        if challenge and challenge in CHALLENGES:
            outcome['points'] = int(outcome['points'] * CHALLENGES[challenge]['mult'])
        return outcome
    # LFI patterns
    if '../' in p or '%2e%2e%2f' in p or 'etc/passwd' in p:
        outcome.update({"message": "simulated LFI detected", "points": base['lfi'], "vuln": 'lfi'})
        if challenge and challenge in CHALLENGES:
            outcome['points'] = int(outcome['points'] * CHALLENGES[challenge]['mult'])
        return outcome
    # RCE-like patterns (dangerous markers only)
    if any(tok in p for tok in ('; ls', '; cat', '&&', '`', '$(')):
        outcome.update({"message": "simulated RCE-like input detected (not executed)", "points": base['rce'], "vuln": 'rce'})
        if challenge and challenge in CHALLENGES:
            outcome['points'] = int(outcome['points'] * CHALLENGES[challenge]['mult'])
        return outcome

    outcome['message'] = 'no vulnerability triggered'
    return outcome


async def handle_http(reader: asyncio.StreamReader, writer: asyncio.StreamWriter, logger: JSONLogger, enable_vuln: bool = False):
    peer = writer.get_extra_info('peername')
    ip = peer[0] if peer else 'unknown'
    try:
        data = await asyncio.wait_for(reader.read(8192), timeout=2.0)
    except asyncio.TimeoutError:
        data = b""
    req_text = data.decode('utf-8', errors='replace')
    # Improved HTTP request parsing
    try:
        first_line = req_text.splitlines()[0] if req_text else ''
        parts = first_line.split()
        path = parts[1] if len(parts) > 1 else '/'
    except Exception as e:
        path = '/'
        import logging
        logging.warning(f"Malformed HTTP request from {ip}: {e}")
    parsed = urllib.parse.urlparse(path)
    qs = urllib.parse.parse_qs(parsed.query)

    log_entry = {
        "proto": "http",
        "ip": ip,
        "request": first_line if 'first_line' in locals() else '',
        "raw": req_text,
    }

    body = "<html><body><h1>Apache/2.2.8 (Ubuntu) Server at example.com</h1><p>Welcome</p></body></html>"

    # Vulnerable simulation: only active when enabled by the operator
    if enable_vuln and parsed.path.startswith('/vuln'):
        payload = ''
        # accept payload in either 'payload' or 'cmd' parameter for convenience
        if 'payload' in qs:
            payload = qs.get('payload', [''])[0]
        elif 'cmd' in qs:
            payload = qs.get('cmd', [''])[0]
        # optional challenge id: easy, normal, hard, expert, hacker
        challenge = qs.get('challenge', ['normal'])[0]
        # pass challenge to simulation and recalc outcome
        outcome = _simulate_vulnerability(payload, challenge=challenge)
        log_entry['vuln_attempt'] = {'payload': payload, 'outcome': outcome, 'challenge': challenge}
        if outcome.get('exposed_flag'):
            body = f"<html><body><h1>Secret</h1><pre>{outcome.get('flag')}</pre><p>Points: {outcome.get('points')}</p></body></html>"
            # record scoring event to a scoreboard file next to the main log
            try:
                score_path = logger.path.parent / 'honeypot_scores.jsonl'
                score_entry = {
                    'ts': datetime.utcnow().isoformat() + 'Z',
                    'ip': ip,
                    'payload': payload,
                    'flag': outcome.get('flag'),
                    'points': outcome.get('points', 0),
                    'challenge': challenge
                }
                async with aiofiles.open(score_path, 'a', encoding='utf-8') as sf:
                    await sf.write(json.dumps(score_entry, ensure_ascii=False) + '\n')
            except Exception as e:
                import logging
                logging.warning(f"Error writing score entry: {e}")
        else:
            body = f"<html><body><h1>Vulnerable App</h1><p>{outcome.get('message')}</p></body></html>"

    await logger.log(log_entry)

    resp = (
        "HTTP/1.1 200 OK\r\n"
        "Content-Type: text/html; charset=utf-8\r\n"
        f"Content-Length: {len(body.encode('utf-8'))}\r\n"
        "Connection: close\r\n\r\n"
        + body
    )
    writer.write(resp.encode('utf-8'))
    await writer.drain()
    try:
        writer.close()
        await writer.wait_closed()
    except Exception as e:
        import logging
        logging.warning(f"Error closing HTTP writer: {e}")


async def start_servers(ssh_port: int, http_port: int, log_path: str, enable_vuln: bool = False):
    logger = JSONLogger(Path(log_path))
    loop = asyncio.get_running_loop()
    ssh_server = await asyncio.start_server(lambda r, w: handle_ssh(r, w, logger), host='0.0.0.0', port=ssh_port)
    http_server = await asyncio.start_server(lambda r, w: handle_http(r, w, logger, enable_vuln), host='0.0.0.0', port=http_port)

    print(f"[+] SSH fake server listening on {ssh_port}")
    print(f"[+] HTTP fake server listening on {http_port} (vuln={'enabled' if enable_vuln else 'disabled'})")
    try:
        async with ssh_server, http_server:
            await asyncio.gather(ssh_server.serve_forever(), http_server.serve_forever())
    except asyncio.CancelledError:
        pass


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--ssh-port', type=int, default=2222)
    parser.add_argument('--http-port', type=int, default=8080)
    parser.add_argument('--log', type=str, default='honeypot.log')
    parser.add_argument('--enable-vuln', action='store_true', help='Enable the simulated vulnerable HTTP endpoint at /vuln')
    args = parser.parse_args()
    try:
        asyncio.run(start_servers(args.ssh_port, args.http_port, args.log, enable_vuln=args.enable_vuln))
    except KeyboardInterrupt:
        print('\nShutting down')
